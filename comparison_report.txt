
PACKAGE : endee
v1      : 0.1.9
v2      : 0.1.10
==================================================
ğŸ“„ LINE BY LINE CODE DIFF
==================================================

ğŸ“„ endee/endee.py
                     token=self.token,
                     url=self.base_url,
                     version=self.version,
â–                  params=metadata.model_dump(by_alias=True),
â•                  params=metadata.dict(by_alias=True),
                     session_client_manager=self.session_manager,
                 )
             else:
                     token=self.token,
                     url=self.base_url,
                     version=self.version,
â–                  params=metadata.model_dump(by_alias=True),
â•                  params=metadata.dict(by_alias=True),
                     session_client_manager=self.client_manager,
                 )
     

ğŸ“„ endee/schema.py
     import sys
     from typing import Any, Dict, List, Optional, Union
     
â–  from pydantic import BaseModel, ConfigDict, Field, field_validator, model_validator
â•  from pydantic import BaseModel, Field, root_validator, validator
     
     from .constants import (
         DEFAULT_EF_SEARCH,
     class VectorItem(BaseModel):
         """Model for a single vector item in an upsert operation."""
     
â–      id: str = Field(..., min_length=1)
â•      id: str
         vector: List[float]
         meta: Optional[Dict[str, Any]] = Field(default_factory=dict)
         filter: Optional[Dict[str, Any]] = Field(default_factory=dict)
         sparse_indices: Optional[List[int]] = None
         sparse_values: Optional[List[float]] = None
     
â–      @model_validator(mode="after")
â–      def validate_sparse_data(self) -> "VectorItem":
â–          if (self.sparse_indices is None) != (self.sparse_values is None):
â•      @validator("id")
â•      @classmethod
â•      def validate_id(cls, v: str) -> str:
â•          if len(v) < 1:
â•              raise ValueError("id must not be empty")
â•          return v
â•  
â•      @root_validator
â•      @classmethod
â•      def validate_sparse_data(cls, values: Dict[str, Any]) -> Dict[str, Any]:
â•          sparse_indices = values.get("sparse_indices")
â•          sparse_values = values.get("sparse_values")
â•  
â•          if (sparse_indices is None) != (sparse_values is None):
                 raise ValueError(
                     "Both sparse_indices and sparse_values must be provided together"
                 )
â–          if self.sparse_indices is not None and len(self.sparse_indices) != len(
â–              self.sparse_values
â–          ):
â•          if sparse_indices is not None and len(sparse_indices) != len(sparse_values):
                 raise ValueError("sparse_indices and sparse_values must match in length")
â–          return self
â•          return values
     
     
     class QueryRequest(BaseModel):
         sparse_indices: Optional[List[int]] = None
         sparse_values: Optional[List[float]] = None
     
â–      @model_validator(mode="after")
â–      def validate_query_type(self) -> "QueryRequest":
â–          has_dense = self.vector is not None
â–          has_sparse = self.sparse_indices is not None or self.sparse_values is not None
â•      @root_validator
â•      @classmethod
â•      def validate_query_type(cls, values: Dict[str, Any]) -> Dict[str, Any]:
â•          vector = values.get("vector")
â•          sparse_indices = values.get("sparse_indices")
â•          sparse_values = values.get("sparse_values")
â•  
â•          has_dense = vector is not None
â•          has_sparse = sparse_indices is not None or sparse_values is not None
     
             if not has_dense and not has_sparse:
                 raise ValueError(
                     " must be provided."
                 )
     
â–          if (self.sparse_indices is None) != (self.sparse_values is None):
â•          if (sparse_indices is None) != (sparse_values is None):
                 raise ValueError(
                     "Both sparse_indices and sparse_values must be provided together"
                 )
     
â–          if self.sparse_indices is not None and len(self.sparse_indices) != len(
â–              self.sparse_values
â–          ):
â•          if sparse_indices is not None and len(sparse_indices) != len(sparse_values):
                 raise ValueError("sparse_indices and sparse_values must match in length")
     
â–          return self
â•          return values
     
     
     class IndexCreateRequest(BaseModel):
         version: Optional[int] = None
         sparse_dim: int = Field(default=0, ge=0, le=sys.maxsize)
     
â–      @field_validator("name")
â•      @validator("name")
         @classmethod
         def validate_name(cls, v: str) -> str:
             if not re.match(r"^[a-zA-Z0-9_]+$", v):
                 )
             return v
     
â–      @field_validator("space_type")
â•      @validator("space_type")
         @classmethod
         def validate_space_type(cls, v: str) -> str:
             v = v.lower()
                 )
             return v
     
â–      @field_validator("precision")
â•      @validator("precision")
         @classmethod
         def validate_precision(cls, v: Union[str, Precision]) -> Union[str, Precision]:
             if isinstance(v, Precision):
     class IndexMetadata(BaseModel):
         """Model for index metadata returned by the server."""
     
â–      model_config = ConfigDict(populate_by_name=True)
â•      class Config:
â•          allow_population_by_field_name = True
     
         name: Optional[str] = Field(None, alias="name")
         lib_token: str

ğŸ“„ setup.py
     setup(
         # Package Metadata
         name="endee",
â–      version="0.1.9",
â•      version="0.1.10",
         author="Endee Labs",
         author_email="dev@endee.io",
         description=(
             "numpy>=2.2.4",  # Array operations and vector normalization
             "msgpack>=1.1.0",  # Efficient binary serialization
             "orjson>=3.11.5",  # Ultra-fast JSON serialization/deserialization
â–          "pydantic>=2.0.0",  # Data validation and settings management
â•          "pydantic==1.10.26",  # Data validation and settings management
         ],
         # Python Version Requirements
         python_requires=">=3.6",
==================================================
ğŸ” CHANGED FUNCTION SIGNATURES
==================================================
(NEW = added in v0.1.10 | REMOVED = absent in v0.1.10 compared to v0.1.9)

ğŸ“ endee/schema.py
  âœ… NEW (v0.1.10):     def validate_id(cls, v)
  âœï¸  CHANGED:
      v0.1.9: def validate_query_type(self)
      v0.1.10: def validate_query_type(cls, values)
  âœï¸  CHANGED:
      v0.1.9: def validate_sparse_data(self)
      v0.1.10: def validate_sparse_data(cls, values)
==================================================
ğŸ“¦ DEPENDENCIES COMPARISON
==================================================
(Added = new in v0.1.10 | Removed = absent in v0.1.10 compared to v0.1.9)
No dependency changes found.